# Execution begins at address 0 
  .pos 0
  irmovq stack, %rsp    # Set up stack pointer
  call main             # Execute main program
  halt                  # Terminate program 

# Array of 6 elements
  .align 8
array:  
  .quad 0x0000000000000000
  .quad 0x0000000000000004
  .quad 0xfffffffffffffffd
  .quad 0x0000000000000000
  .quad 0x0000000000000004
  .quad 0xffffffffffffffff
  .quad 0x0000000000000002
  .quad 0x0000000000000000
  .quad 0x0000000000000001
  .quad 0x0000000000000005

main: 
  irmovq array,%rdi
  irmovq $10,%rsi       # array length
  irmovq $100,%rbp      # Constant 100
  call sum              # sum(array, 4)
  ret

# long sum(long *start, long count)
# start in %rdi, count in %rsi
sum:  
  irmovq $8,%r8         # Constant 8
  irmovq $1,%r9         # Constant 1
  irmovq $-1,%r11
  xorq %rax,%rax        # sum = 0
  andq %rsi,%rsi        # Set CC
  jmp test              # Goto test
loop: 
  mrmovq (%rdi),%r10    # Get *start
  andq %r10,%r10
  #iaddq $10,%r11
  jl arith
  ishlq $2,%r10
  addq %r10,%rax
  #addq %r10,%rax        # Add to sum
  addq %r8,%rdi         # start++
  subq %r9,%rsi         # count--.  Set CC
test: 
  jne loop              # Stop when 0
  ret                   # Return
arith:
  xorq %r11,%r10 
  iaddq $1,%r10
  ishaq $2,%r10
  addq %r10,%rax
  #subq %r10,%rax        # Sub from sum
  addq %r8,%rdi         # start++
  subq %r9,%rsi         # count--.  Set CC
  jmp loop

# Stack starts here and grows to lower addresses
  .pos 0x200
stack:

