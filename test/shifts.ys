# Execution begins at address 0 
  .pos 0
  irmovq stack, %rsp    # Set up stack pointer
  call main             # Execute main program
  halt                  # Terminate program 

# Array of 10 elements
  .align 8
array:  
  .quad 0x0000000000000000
  .quad 0x0000000000000004
  .quad 0xfffffffffffffffc
  .quad 0x0000000000000000
  .quad 0x0000000000000004
  .quad 0xfffffffffffffffe
  .quad 0x0000000000000002
  .quad 0x0000000000000000
  .quad 0x0000000000000001
  .quad 0x0000000000000005

main: 
  irmovq array,%rdi
  irmovq $10,%rsi       # array length
  irmovq $100,%rbp      # Constant 100
  call sum              # sum()
  ret

# start in %rdi, count in %rsi
sum:  
  irmovq $8,%r8         # Constant 8
  irmovq $1,%r9         # Constant 1
  irmovq $-1,%r11
  xorq %rax,%rax        # sum = 0
  andq %rsi,%rsi        # Set CC
  jmp test              # Goto test
loop: 
  mrmovq (%rdi),%r10    # Get *start
  andq %r10,%r10        # Returns %r10 
  #iaddq $10,%r11       
  jl arith              # If ret is negative, do arithmetic shift
  ishlq $2,%r10
  addq %r10,%rax
  addq %r8,%rdi         # start++
  subq %r9,%rsi         # count--.  Set CC
test: 
  jne loop              # Stop when 0
  ret                   # Return
arith:
  xorq %r11,%r10        # xor %r10 to positive
  ishaq $-2,%r10
  addq %r10,%rax
  addq %r8,%rdi         # start++
  subq %r9,%rsi         # count--.  Set CC
  jmp loop

# Stack starts here and grows to lower addresses
  .pos 0x200
stack:

